### 传输层服务（协议）

* 提供了应用进程之间的一种逻辑通信机制（位于网络层之上，依赖网络层，对网络层服务进行增强）（端到端）（网络层提供的是主机之间的逻辑通信机制）
* 发送方：将应用递交的消息分成一个或多个的Segment，并向下传给网络层
* 接收方：将接收到的Segment组装成消息，并向上交给应用层
* 提供多种协议：TCP/UDP
TCP：可靠，按序，提供拥塞控制，流量控制，面向连接

UDP：不可靠（尽力而为）

均不提供延迟和带宽的保障
 

#### 多路复用/分用

如果某层的一个洗衣对应直接上层的多个协议/实体，则需要多路复用/分用

1. 每个数据报携带IP地址，目的IP地址
2. 每个数据报携带一个传输层的段（segment）
3. 每个段携带源端口号和目的端口号 
4. 主机收到segment后传输协议提取IP地址和端口号，将segment导向相应socket
```
源端口号|目的端口号
其他头部信息
应用数据

TCP段格式
```

* 多路复用（发送端，从多个Socket接收数据，为每块数据封装上头信息，形成segment交给网络层）
* 多路分用（接收端，根据头部信息将接收到的segment交给正确的Socket即不同进程）

UDP分用：二元组标识（目的IP和目的端口号）
TCP分用：四元组标识（源IP,源端口，目的IP，目的端口）通过源端口号区分不同连接
TCP分用(多线程)：通过进程创建多个线程进行服务

#### UDP(User Datagram Protocol)(Best effort尽力而为)（和网络层一样不可靠）
* 复用/分用
* 简单的错误校验
* 无连接（丢失）（非按需到达）（延迟显著减少）
* 在UDP上实现可靠数据传输：
在应用层增加可靠性机制，应用特定的错误恢复机制
```
源端口号|目的端口号
length|chekcsum
其他头部信息
应用数据

UDP段格式
```
* UDP校验和（checksum）:检测UDP段在传输中是否发生错误

发送方：将段的内容视为16-bit整数，计算所有整数的和，高位要被加到低位，将得到的值按位求反，得到校验和放入校验和字段
```
checksum 计算

 1110011001100110
+1101010101010101
11011101110111011(发生进位)
 1011101110111100（低位+1）
 0100010001000011（按位取反得出checksum）
```
接收方：计算收到段和，将其和校验和比对

#### 可靠数据传输机制（不错，不丢，不乱）（Reliable Data Transfer可靠数据传输RDT）
* 可靠数据传输协议Rdt1.0

假设底层信道是完成可靠的：

不会发生错误(bit error)

不会丢弃分组

```
rdt_send()//上层网络应用单项的效用下层可靠协议
udt_send()
rdt_rcv()
deliver_data()//下层协议将结果单向交付给上层网络
```

* 可靠数据传输协议Rdt2.0

可能产生位错误

如何确认可能出现位翻转：

利用校验和检测位错误

 如何从错误中恢复：
 
 确认机制（Acknowledgements,ACK）接收方显式地告知发送方分组已正确接收
 
 NAK:接收方显式告知发送方数组有错误，发送方收到NAK后重传分组

基于这种重传机制的rdt协议称为ARQ(Automatic Repeat reQuest)协议

Rdt2.0中引入的新机制：
1. 差错检测
2. 接受反馈:ACK/NAK
3. 重传

* 可靠数据传输协议Rdt2.1
2.0存在ACK/NAK消息发生错误/被破坏问题：

为ACK/NAK增加校验和，检错并纠错（不合适）

发送方搜到被破坏的ACK/NAK时不知道接收方发生了什么，添加额外的控制消息（不合适）

为ACK/NAK增加校验和，如果ACK/NAK坏掉，发送方重传，但不能简单重传，会产生重复分组（合适），通过增加序列号解决重复分组问题（发送方给每个分组增加序列号，接收方丢弃重复分组）

* 可靠数据传输协议Rdt2.2（取消NAK）

接收方：通过ACK告知最后一个被正确接收的分组，在ACK消息中显示的加入被确认分组的序列号

发送方：收到重复的ACK后，采用与收到NAK消息相同的动作：重传当前分组

* 可靠数据传输协议Rdt3.0
 假设信道会发生错误，也可能丢失分组
 
 解决丢失问题：
 发送方等待“合理”时间（超时），如果没有收到ACK就重传（需要定时器）
 
 如果分组或ACK只是延迟而不是丢失，通过系列号机制解决重传产生的重复（接收方需要在ACK中显式告知所确认的分组）
 
 
 由于停等操作，性能差，利用率0.00027
 
 通过流水线机制打破效率低下：
 1. 允许发送方在收到ACK之前连续发送多个分组（更大的序列范围）（发送方和接收方需要更大的存储空间以缓存分组）
 2. 要实现流水线机制需要“滑动窗口协议（Sliding-window protocol）（GBN,SR）”:
 
 窗口：
 
 允许使用的序列范围
 
 窗口的尺寸为N:最多有N个等待确认的消息
 
 
滑动窗口：

随着协议的运行，窗口在序列号空间内向前滑动
```
||||||||||||||
   ↑------↑
箭头左边的是已完成ack的，箭头中间包含发送未响应和可使用的，箭头右边是不可使用的   
```

GBN协议(Go-Back-N)

发送放：
1. 返祖头包含k-bit序列号
2. 窗口尺寸为N，最多允许N个分组未确认
3. 采用累积确认机制，收到ACK包含N，意思是确认到N的分组包含N都已经被正确接收（可能重复）
4. 为空的分组设置定时器
5. 超时事件：GBN选择重传序列号大于等于N且还未收到ACK所有分组
6. 存在乱序到达的分组：GBN选择直接丢弃

```
例题：

问：采用GBN协议，发送方返送编号为0-7的帧，当计时器超时，发送方收到0，2，3号帧的确认，则需要重发帧数是多少，分别是哪几个?

答：GBN使用累积确认，所以此时需要重发4个，依次为4，5，6，7（3之前包括3都确认了，所以从4开始重发）

```

SR协议(Selective Repeat)

GBN存在重传很多分组缺陷

SR存在无法识别重复的序列号缺陷（解决方法把序列号扩大，序列号大于等于发送方窗口长度+接收方窗口长度）


接收方：
1. 对每个分组单独进行确认
2. 设置缓存机制，缓存乱序到达的分组
3. 接收方存在窗口（期望收到还没收到，乱序到达分组，可以接收的）
[![V7F2uR.md.png](https://s2.ax1x.com/2019/06/16/V7F2uR.md.png)](https://imgchr.com/i/V7F2uR)

[![V7FLDI.md.png](https://s2.ax1x.com/2019/06/16/V7FLDI.md.png)](https://imgchr.com/i/V7FLDI)
发送方：
1. 只需要重传那些没有收到ACK的分组（为每个分组设置定时器）

#### TCP

1. 点对点（一个发送方一个接收方）
2. 可靠的按需的字节流
3. 流水线机制（TCP拥塞控制和流量控制机制）
4. 发送方/接收方缓存
5. 全双工（同一连接中能够传输双向数据流）
6. 面向连接（连接状态只在连接的两端中维护，在沿途节点中并不维护状态）（包括两台主机上的缓存，连接状态变量，socket等）
7. 流量控制机制

TCP段结构:
[![V7AnTP.md.png](https://s2.ax1x.com/2019/06/16/V7AnTP.md.png)](https://imgchr.com/i/V7AnTP)

序列号seg：指的是segment中第一个字节的编号，不是segment的编号，建立TCP时，双方随机选择序列号

ACKs:希望接收到下一个字节的序列号（累积确认，该序列号之前所有字节均已被正确收到）

处理乱序到达：TCP规范没有规定，由实现者自己做出决定

TCP可靠数据传输：

计算RTT：测量从段发出到收到ACK时间，测量多个值，求平均值，形成估计值

* TCP发送方事件

1. 创建Segment,序列号是Segment第一个字节的编号
2. 开启定时器
3. 设置超时时间
4. 超时：重传引起超时的Segment，重启定时器
重传实例
[![V7EmjJ.md.png](https://s2.ax1x.com/2019/06/16/V7EmjJ.md.png)](https://imgchr.com/i/V7EmjJ)
5. 收到ACK,如果是没确认过的segment就滑动窗口
6. 快速重传机制：如果发送方收到同一个数据的3个ack，那么确定这个数据段后的段丢失（定时器超时之前重传）
 
 TCP流量控制：
 1. 接收方通过在Segment头部字段将RcWindow告诉发送方
 2. 发送方限制自己已经发送但还未收到ACK的数据不超过接受方空闲的RcWindow尺寸
 3. 当接收方RcWindow=0时，发送方仍可以发送一个很小的信息以获取新的RcWindow防止死锁
 
TCP连接管理：

三次握手  
```
step1：客户端向服务器发送一个SYN（=1）段（不携带数据）seq（选择自己的初始序列号）

step2:服务端收到SYN,返回带有SYNACK（SYN=1,seq服务端期望序列，ack客户端序列+1）的报文段（分配缓存）

step3:客户端收到SYNACK后，答复带有ACK（SYN=0,seq服务器所期望的序列号，ack服务器序列号+1）的报文段（可能包含数据）
```
[![V7hViD.md.png](https://s2.ax1x.com/2019/06/17/V7hViD.md.png)](https://imgchr.com/i/V7hViD)

四次挥手
```
step1：客户端向服务器发送TCP FIN控制segment

step2:服务器收到FIN回复ACK,关闭连接，接着服务器会发送FIN

step3:客户顿收到FIN,回复ACK（进入等待，如果收到FIN会重新发送ACK）

step4:服务器收到ACK连接关闭
```
[![V7hdLq.md.png](https://s2.ax1x.com/2019/06/17/V7hdLq.md.png)](https://imgchr.com/i/V7hdLq)

拥塞控制 

* 太多主机发送了太多数据，以至于网络无法处理
* 导致分组丢失（缓存溢出）
* 导致分组延迟变大（路由器缓存排队）

![VLjwK1.png](https://s2.ax1x.com/2019/06/19/VLjwK1.png)

![VLj0Dx.png](https://s2.ax1x.com/2019/06/19/VLj0Dx.png)

[![VLjy5D.md.png](https://s2.ax1x.com/2019/06/19/VLjy5D.md.png)](https://imgchr.com/i/VLjy5D)

方法：

* 端到端拥塞控制（TCP采用这种方法）
1. 通过调整CongWin(Congestion Window拥塞窗口)
2. 通过Loss事件=timeout或3个重复ack判断为拥塞
3. 合理的调整速率
```
加性增-乘性减：AIMD
Additive increase:每个RTT将CongWin增大一个MSS(避免拥塞)
Multiplicative Decrease:发生loss后将CongWin减半（快速降下来）

慢启动：SS（slow start）
TCP建立时候，CongWin=1，然后成指数增长（每个RTT将CongWin翻倍）
```
![VXdMid.png](https://s2.ax1x.com/2019/06/19/VXdMid.png)

![VXdlRI.png](https://s2.ax1x.com/2019/06/19/VXdlRI.png)


指数增长和线性增长切换条件：
1. 增长：先是指数（慢启动），达到Threshold（拥塞避免）变成线性
2. 降低：发生Loss时候，直接降低到起始点，然后Threshold降低成Loss前一半

![VXrlK1.png](https://s2.ax1x.com/2019/06/19/VXrlK1.png)

例题
![VjCQSK.png](https://s2.ax1x.com/2019/06/20/VjCQSK.png)

不同判断条件不同处理：

1. 3个重复的ACK:CongWin直接切到一半，然后线性增长
2. TimeOut事件：ConWin直接设为一个MSS（Maximum Segment Size最大报文长度），然后指数增长，达到threshold，再线性增长（表示更严重的拥塞）



* 网络辅助的拥塞控制，路由器显式反馈网络拥塞（ATM）

1. data cells：数据cell
```
data cell包含

EFCI位：拥塞的交换机将其设为1

```
2. RM(resource management)cells:由收放发送给发送方
```
RM包含


NI bit:rate不许增长
CI bit:拥塞指示（如果签名的data cell中的EFCI被置1，那么置CI位）
ER 2bit:速率
```

TCP性能

```
给定拥塞窗口和RTT，计算平均吞吐率

* 发生超时时ConWin为W，吞吐率是W/RTT
* 超时后，ConWin=W/2,吞吐率为W/2RTT
* 平均吞吐率0.75W/RTT
```

TCP具有公平性
* 多媒体通常不使用TCP以免被拥塞控制机制限制速率（使用UDP以恒定速率发送，容忍丢失）（产生不公平）
* 开启多个并发TCP连接，导致不公平




