# 柔性事务 ：TCC两阶段补偿型
* TCC是Try-Confirm-Cancel的简称:
## 场景范例
[![wzoCMq.md.png](https://s1.ax1x.com/2020/09/24/wzoCMq.md.png)](https://imgchr.com/i/wzoCMq)


## Try阶段：
* 完成所有业务检查（一致性），预留业务资源(准隔离性)
* 回顾上面航班预定案例的阶段1，机票就是业务资源，所有的资源提供者(航空公司)预留都成功，try阶段才算陈宫
## Confirm阶段：
* 确认执行业务操作，不做任何业务检查， 
* 只使用Try阶段预留的业务资源。回顾上面航班预定案例的阶段2，美团APP确认两个航空公司机票都预留成功，因此向两个航空公司分别发送确认购买的请求。

## Cancel阶段：
* 取消Try阶段预留的业务资源。回顾上面航班预定案例的阶段2，如果某个业务方的业务资源没有预留成功，则取消所有业务资源预留请求。 

## TCC与XA两阶段提交有着异曲同工之妙，下图列出了二者之间的对比
* [![wzoRln.md.png](https://s1.ax1x.com/2020/09/24/wzoRln.md.png)](https://imgchr.com/i/wzoRln)


## 相似处：

### 在阶段1：
* 在XA中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作(insert、delete、update等)；
* 在TCC中，是主业务活动请求(try)各个从业务服务预留资源

### 在阶段2：
* XA根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支。
* TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。

## 不同处：
* XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。XA事务中的两阶段提交内部过程是对开发者屏蔽的，回顾我们之前讲解JTA规范时，通过UserTransaction的commit方法来提交全局事务，这只是一次方法调用，其内部会委派给TransactionManager进行真正的两阶段提交，因此开发者从代码层面是感知不到这个过程的。而事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。
* TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。 TCC中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在。如上述航班预定案例：在第一阶段，航空公司需要提供try接口(机票资源预留)。在第二阶段，航空公司提需要提供confirm/cancel接口(确认购买机票/取消预留)。开发者明显的感知到了两阶段提交过程的存在。try、confirm/cancel在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的ACID特性。其中：1、try过程的本地事务，是保证资源预留的业务逻辑的正确性。2、confirm/cancel执行的本地事务逻辑确认/取消预留资源，以保证最终一致性，也就是所谓的补偿型事务(Compensation-Based Transactions)。由于是多个独立的本地事务，因此不会对资源一直加锁

## 什么是补偿事物
* 提交过程分为2个阶段，第二阶段的confirm/cancel执行的事务属于补偿事务

## TCC事务模型 VS DTP事务模型
[![wz70IS.md.png](https://s1.ax1x.com/2020/09/24/wz70IS.md.png)](https://imgchr.com/i/wz70IS)

### ***1.TCC模型中的主业务服务 相当于 DTP模型中的AP，TCC模型中的从业务服务 相当于 DTP模型中的RM***
* 在DTP模型中，应用AP操作多个资源管理器RM上的资源；
* 而在TCC模型中，是主业务服务操作多个从业务服务上的资源。例如航班预定案例中，美团App就是主业务服务，而川航和东航就是从业务服务，主业务服务需要使用从业务服务上的机票资源。不同的是DTP模型中的资源提供者是类似于Mysql这种关系型数据库，而TCC模型中资源的提供者是其他业务服务

### ***2.TCC模型中，从业务服务提供的try、confirm、cancel接口 相当于DTP模型中RM提供的prepare、commit、rollback接口***
* XA协议中规定了DTP模型中定RM需要提供prepare、commit、rollback接口给TM调用，以实现两阶段提交。
* 而在TCC模型中，从业务服务相当于RM，提供了类似的try、confirm、cancel接口。

### 事务管理器
* DTP模型和TCC模型中都有一个事务管理器。不同的是：在DTP模型中，阶段1的(prepare)和阶段2的(commit、rollback)，都是由TM进行调用的。
* 在TCC模型中，阶段1的try接口是主业务服务调用(绿色箭头)，阶段2的(confirm、cancel接口)是事务管理器TM调用(红色箭头)。这就是 TCC分布式事务模型的二阶段异步化功能，从业务服务的第一阶段执行成功，主业务服务就可以提交完成，然后再由事务管理器框架异步的执行各从业务服务的第二阶段。
* 这里牺牲了一定的隔离性和一致性的，但是提高了长事务的可用性。问题来了，既然第二阶段是异步执行的，主业务服务怎么知道异步执行的结果呢？发消息异步通知？返回一个id，后面让业务去查？

## TCC事务的优缺点：
* ***优点：*** XA两阶段提交资源层面的，而TCC实际上把资源层面二阶段提交上提到了业务层面来实现。有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能地下问题。
* ***缺点：*** 主业务服务和从业务服务都需要进行改造，从业务方改造成本更高。还是航班预定案例，原来只需要提供一个购买接口，现在需要改造成try、confirm、canel3个接口，开发成本高。
